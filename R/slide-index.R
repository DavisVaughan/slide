make_locate_window_start <- function() {
  previous_position <- 1L

  function(i, range_start, n) {
    position <- previous_position

    i_position <- vec_slice(i, position)

    while (vec_lt(i_position, range_start)) {
      if (position == n) {
        previous_position <<- position
        return(position)
      }

      position <- position + 1L

      i_position <- vec_slice(i, position)
    }

    previous_position <<- position
    position
  }
}

make_locate_window_stop <- function() {
  previous_position <- 1L

  function(i, range_stop, n) {
    position <- previous_position
    i_position <- vec_slice(i, position)

    while (vec_lte(i_position, range_stop)) {
      if (position == n) {
        previous_position <<- position
        return(position)
      }

      position <- position + 1L
      i_position <- vec_slice(i, position)
    }

    previous_position <<- position
    position - 1L
  }
}

# ------------------------------------------------------------------------------

check_na_range <- function(x, what) {
  if (is.na(x)) {
    abort(sprintf("`NA` value detected in the index range generated by `%s`.", what))
  }

  invisible(x)
}

# ------------------------------------------------------------------------------

compute_range_starts <- function(i, before) {
  if (is_function(before)) {
    out <- before(i)

    # TODO check that it is strictly increasing

  } else {
    out <- i - before
  }

  if (any(is.na(out))) {
    abort("`NA` value detected in the index range generated by `.before`.")
  }

  out
}

compute_range_stops <- function(i, after) {
  if (is_function(after)) {
    out <- after(i)

    # TODO check that it is strictly increasing

  } else {
    out <- i + after
  }

  if (any(is.na(out))) {
    abort("`NA` value detected in the index range generated by `.after`.")
  }

  out
}

# ------------------------------------------------------------------------------

check_index_size <- function(n, i) {
  n_i <- vec_size(i)

  if (n != n_i) {
    abort(
      sprintf("The size of `.x` (%i) and `.i` (%i) must be the same.", n, n_i)
    )
  }

  invisible()
}

check_before <- function(before) {
  if (is_unbounded(before)) {
    return(before)
  }

  if (is_formula(before, scoped = TRUE, lhs = FALSE)) {
    before <- as_function(before)
    return(before)
  }

  if (!is_function(before)) {
    vec_assert(before, size = 1L, arg = ".before")
  }

  before
}

check_after <- function(after) {
  if (is_unbounded(after)) {
    return(after)
  }

  if (is_formula(after, scoped = TRUE, lhs = FALSE)) {
    after <- as_function(after)
    return(after)
  }

  if (!is_function(after)) {
    vec_assert(after, size = 1L, arg = ".after")
  }

  after
}

check_complete <- function(complete) {
  complete <- vec_cast(complete, logical(), x_arg = ".complete")
  vec_assert(complete, size = 1L, arg = ".complete")
  complete
}

check_params <- function(params) {
  params$before <- check_before(params$before)
  params$after <- check_after(params$after)
  params$complete <- check_complete(params$complete)
  params
}

# ------------------------------------------------------------------------------

slide_index_impl <- function(.x,
                             .i,
                             .f,
                             ...,
                             .before,
                             .after,
                             .complete,
                             .constrain,
                             .ptype) {
  n_out <- vec_size(.x)
  .f <- as_function(.f)

  check_index_size(n_out, .i)

  split <- vec_split_id(.i)
  key <- split$key
  entries <- split$id

  # Number of unique index values
  iteration <- 1L
  iteration_max <- vec_size(key)

  before_unbounded = is_unbounded(.before)
  after_unbounded = is_unbounded(.after)

  # TODO
  #params <- check_params(params)
  if (is_formula(.before, scoped = TRUE, lhs = FALSE)) {
    .before <- as_function(.before)
  }

  if (is_formula(.after, scoped = TRUE, lhs = FALSE)) {
    .after <- as_function(.after)
  }

  range_starts <- NULL
  if (!before_unbounded) {
    range_starts <- compute_range_starts(key, .before)
  }

  range_stops <- NULL
  if (!after_unbounded) {
    range_stops <- compute_range_stops(key, .after)
  }

  ptype_range <- vec_ptype_common(key, range_starts, range_stops)

  if (!before_unbounded) {
    range_starts <- vec_cast(range_starts, ptype_range)
    range_starts <- vec_proxy_compare(range_starts)
  }

  if (!after_unbounded) {
    range_stops <- vec_cast(range_stops, ptype_range)
    range_stops <- vec_proxy_compare(range_stops)
  }

  if (!before_unbounded && !after_unbounded) {
    check_range_start_not_past_stop(range_starts, range_stops)
  }

  .i <- vec_cast(.i, ptype_range)
  .i <- vec_proxy_compare(.i)

  i_first <- vec_slice(.i, 1L)
  i_last <- vec_slice(.i, n_out)

  # Iteration adjustment
  if (.complete) {
    if (!before_unbounded) {
      range_starts_first <- vec_slice(range_starts, 1L)

      if (vec_gt(i_first, range_starts_first)) {
        i_first <- vec_recycle(i_first, iteration_max)
        range_starts_before <- vec_gt(i_first, range_starts)
        forward_adjustment <- sum(range_starts_before)
        iteration <- iteration + forward_adjustment
      }
    }

    if (!after_unbounded) {
      range_stops_last <- vec_slice(range_stops, iteration_max)

      if (vec_lt(i_last, range_stops_last)) {
        i_last <- vec_recycle(i_last, iteration_max)
        range_stops_after <- vec_lt(i_last, range_stops)
        iteration_max <- iteration_max - sum(range_stops_after)
      }
    }
  } else {
    if (!before_unbounded) {
      range_starts_last <- vec_slice(range_starts, iteration_max)

      if (vec_lt(i_last, range_starts_last)) {
        i_last <- vec_recycle(i_last, iteration_max)
        range_starts_after <- vec_lt(i_last, range_starts)
        iteration_max <- iteration_max - sum(range_starts_after)
      }
    }

    if (!after_unbounded) {
      range_stops_first <- vec_slice(range_stops, 1L)

      if (vec_gt(i_first, range_stops_first)) {
        i_first <- vec_recycle(i_first, iteration_max)
        range_stops_before <- vec_gt(i_first, range_stops)
        forward_adjustment <- sum(range_stops_before)
        iteration <- iteration + forward_adjustment
      }
    }
  }

  out <- vec_init(.ptype, n_out)

  locate_window_start <- make_locate_window_start()
  locate_window_stop <- make_locate_window_stop()

  window_start <- 1L
  window_stop <- n_out

  while(iteration <= iteration_max) {
    if (!before_unbounded) {
      range_start <- vec_slice(range_starts, iteration)
      window_start <- locate_window_start(.i, range_start, n_out)
    }

    if (!after_unbounded) {
      range_stop <- vec_slice(range_stops, iteration)
      window_stop <- locate_window_stop(.i, range_stop, n_out)
    }

    # This can happen with an irregular index, and is a sign of the full window
    # being between two index points and means we select nothing
    if (window_stop < window_start) {
      window_start <- 0L
      window_stop <- 0L
    }

    slice <- vec_slice(.x, seq2(window_start, window_stop))

    elt <- .f(slice, ...)

    entry <- entries[[iteration]]

    if (.constrain) {
      elt <- vec_cast(elt, .ptype)

      if (vec_size(elt) != 1L) {
        abort(sprintf("The size of each result of `.f` must be size 1. Iteration %i was size %i.", iteration, vec_size(elt)))
      }

      out <- vec_assign(out, entry, elt)
    } else {
      for (j in entry) {
        out[[j]] <- elt
      }
    }

    iteration <- iteration + 1L
  }

  out
}

# ------------------------------------------------------------------------------

# TODO - tell me where!
check_range_start_not_past_stop <- function(starts, stops) {
  not_ok <- any(vec_compare(starts, stops) == 1L)

  if (not_ok) {
    abort("In the ranges generated by `.before` and `.after`, the start of the range is after the end of the range.")
  }

  invisible()
}

# ------------------------------------------------------------------------------
# Should only ever pass objects of size 1 through here

vctrs_compare <- vctrs:::vctrs_compare

vec_gt <- function(x, y) {
  .Call(vctrs_compare, x, y, FALSE) > 0L
  #vec_compare(x, y) > 0L
}

vec_gte <- function(x, y) {
  .Call(vctrs_compare, x, y, FALSE) >= 0L
  #vec_compare(x, y) >= 0L
}

vec_lt <- function(x, y) {
  .Call(vctrs_compare, x, y, FALSE) < 0L
  #vec_compare(x, y) < 0L
}

vec_lte <- function(x, y) {
  .Call(vctrs_compare, x, y, FALSE) <= 0L
  #vec_compare(x, y) <= 0L
}

# ------------------------------------------------------------------------------

slide_index <- function(.x,
                        .i,
                        .f,
                        ...,
                        .before = 0L,
                        .after = 0L,
                        .complete = FALSE
) {
  slide_index_impl(
    .x,
    .i,
    .f,
    ...,
    .before = .before,
    .after = .after,
    .complete = .complete,
    .constrain = FALSE,
    .ptype = list()
  )
}
