# ------------------------------------------------------------------------------

# Look backwards until index[[i]] is past range_start, then add 1 to position
# Additional check to see if the start of our window is
# already outside the last value (no data here)
locate_window_start_behind_current <- function(i, params, range_params) {
  position <- params$position_out
  i_position <- vec_slice(i, position)

  while (vec_gte(i_position, range_params$start)) {
    if (position == 1L) {
      return(position)
    }

    position <- position - 1L
    i_position <- vec_slice(i, position)
  }

  # Always goes 1 too far, so add it back afterwards
  position + 1L
}

# Look forward until index[[i]] is at or past range_start
locate_window_start_ahead_of_current <- function(i, params, range_params) {
  position <- params$position_out
  i_position <- vec_slice(i, position)

  while (vec_lt(i_position, range_params$start)) {
    if (position == params$n_out) {
      return(position)
    }

    position <- position + 1L
    i_position <- vec_slice(i, position)
  }

  position
}

# Look forward until index[[i]] is past range_stop, then subtract 1 from position
locate_window_stop_ahead_of_current <- function(i, params, range_params) {
  position <- params$position_out
  i_position <- vec_slice(i, position)

  while (vec_lte(i_position, range_params$stop)) {
    if (position == params$n_out) {
      return(position)
    }

    position <- position + 1L
    i_position <- vec_slice(i, position)
  }

  # Always goes 1 too far, so back it off afterwards
  position - 1L
}

# Look backwards until index[[i]] is at or past range_stop
# Additional check to see if the end of our window is
# already outside the first value (no data here)
locate_window_stop_behind_current <- function(i, params, range_params) {
  position <- params$position_out
  i_position <- vec_slice(i, position)

  while (vec_gt(i_position, range_params$stop)) {
    if (position == 1L) {
      return(position)
    }

    position <- position - 1L
    i_position <- vec_slice(i, position)
  }

  position
}

check_na_range <- function(x, what) {
  if (is.na(x)) {
    abort(sprintf("`NA` value detected in the index range generated by `%s`.", what))
  }

  invisible(x)
}

# ------------------------------------------------------------------------------

locate_window_start <- function(i, params, range_params) {
  if (range_params$start_ahead) {
    locate_window_start_ahead_of_current(i, params, range_params)
  } else {
    locate_window_start_behind_current(i, params, range_params)
  }
}

locate_window_stop <- function(i, params, range_params) {
  if (range_params$stop_behind) {
    locate_window_stop_behind_current(i, params, range_params)
  } else {
    locate_window_stop_ahead_of_current(i, params, range_params)
  }
}

# ------------------------------------------------------------------------------

compute_range_starts <- function(i, before) {
  if (is_function(before)) {
    out <- before(i)
    return(out)
  }

  i - before
}

compute_range_stops <- function(i, after) {
  if (is_function(after)) {
    out <- after(i)
    return(out)
  }

  i + after
}

# ------------------------------------------------------------------------------

is_range_start_ahead_of_current <- function(key_start, range_start) {
  vec_lt(key_start, range_start)
}

is_range_stop_behind_current <- function(key_stop, range_stop) {
  vec_gt(key_stop, range_stop)
}

# ------------------------------------------------------------------------------

check_index_size <- function(n, i) {
  n_i <- vec_size(i)

  if (n != n_i) {
    abort(
      sprintf("The size of `.x` (%i) and `.i` (%i) must be the same.", n, n_i)
    )
  }

  invisible()
}

check_before <- function(before) {
  if (is_unbounded(before)) {
    return(before)
  }

  if (is_formula(before, scoped = TRUE, lhs = FALSE)) {
    before <- as_function(before)
    return(before)
  }

  if (!is_function(before)) {
    vec_assert(before, size = 1L, arg = ".before")
  }

  before
}

check_after <- function(after) {
  if (is_unbounded(after)) {
    return(after)
  }

  if (is_formula(after, scoped = TRUE, lhs = FALSE)) {
    after <- as_function(after)
    return(after)
  }

  if (!is_function(after)) {
    vec_assert(after, size = 1L, arg = ".after")
  }

  after
}

check_complete <- function(complete) {
  complete <- vec_cast(complete, logical(), x_arg = ".complete")
  vec_assert(complete, size = 1L, arg = ".complete")
  complete
}

check_params <- function(params) {
  params$before <- check_before(params$before)
  params$after <- check_after(params$after)
  params$complete <- check_complete(params$complete)
  params
}

# ------------------------------------------------------------------------------

slide_index_impl <- function(.x,
                             .i,
                             .f,
                             ...,
                             .before,
                             .after,
                             .complete,
                             .constrain,
                             .ptype) {
  n_out <- vec_size(.x)
  .f <- as_function(.f)

  check_index_size(n_out, .i)

  split <- vec_split_id(.i)
  split$sizes <- vapply(split$id, vec_size, integer(1))

  # Number of unique index values
  n_index <- vec_size(split$key)

  params <- list(
    before = .before,
    after = .after,
    before_unbounded = is_unbounded(.before),
    after_unbounded = is_unbounded(.after),
    complete = .complete,
    ptype = .ptype,
    constrain = .constrain,
    entry = 1L,
    position_out = 1L,
    position_index = 1L,
    n_out = n_out,
    n_index = n_index
  )

  params <- check_params(params)
  range_params <- init_range_params()

  if (params$before_unbounded && params$after_unbounded) {
    loop_double_unbounded(.x, .f, params, ...)
  } else if (params$before_unbounded) {
    loop_before_unbounded(.x, .i, .f, params, range_params, split, ...)
  } else if (params$after_unbounded) {
    loop_after_unbounded(.x, .i, .f, params, range_params, split, ...)
  } else {
    loop_bounded(.x, .i, .f, params, range_params, split, ...)
  }
}

# ------------------------------------------------------------------------------

init_range_params <- function() {
  list(
    start = NULL,
    stop = NULL,
    start_ahead = NULL,
    stop_behind = NULL,
    start_first = NULL,
    start_last = NULL,
    stop_first = NULL,
    stop_last = NULL
  )
}

# ------------------------------------------------------------------------------

check_range_start_past_stop <- function(params, range_params) {
  if (vec_gt(range_params$start, range_params$stop)) {
    start <- as.character(range_params$start)
    stop <- as.character(range_params$stop)
    abort(sprintf("In iteration %i, the start of the range, %s, cannot be after the end of the range, %s.", params$position_index, start, stop))
  }

  invisible()
}

# ------------------------------------------------------------------------------

loop_bounded <- function(x, i, f, params, range_params, split, ...) {
  range_starts <- compute_range_starts(split$key, params$before)
  range_stops <- compute_range_stops(split$key, params$after)

  ptype_range <- vec_ptype_common(split$key, range_starts, range_stops)

  range_starts <- vec_cast(range_starts, ptype_range)
  range_starts <- vec_proxy_compare(range_starts)
  key_starts <- vec_cast(split$key, ptype_range)
  key_starts <- vec_proxy_compare(key_starts)
  i_starts <- vec_cast(i, ptype_range)
  i_starts <- vec_proxy_compare(i_starts)

  range_stops <- vec_cast(range_stops, ptype_range)
  range_stops <- vec_proxy_compare(range_stops)
  key_stops <- vec_cast(split$key, ptype_range)
  key_stops <- vec_proxy_compare(key_stops)
  i_stops <- vec_cast(i, ptype_range)
  i_stops <- vec_proxy_compare(i_stops)

  range_params$start_first <- vec_slice(key_starts, 1L)
  range_params$start_last <- vec_slice(key_starts, params$n_index)
  range_params$stop_first <- vec_slice(key_stops, 1L)
  range_params$stop_last <- vec_slice(key_stops, params$n_index)

  out <- vec_init(params$ptype, params$n_out)

  while(params$position_index <= params$n_index) {
    key_start <- vec_slice(key_starts, params$position_index)
    key_stop <- vec_slice(key_stops, params$position_index)

    params$entry <- split$id[[params$position_index]]

    range_params$start <- vec_slice(range_starts, params$position_index)
    check_na_range(range_params$start, ".before")

    range_params$stop <- vec_slice(range_stops, params$position_index)
    check_na_range(range_params$stop, ".after")

    check_range_start_past_stop(params, range_params)

    range_params$start_ahead <- is_range_start_ahead_of_current(key_start, range_params$start)
    range_params$stop_behind <- is_range_stop_behind_current(key_stop, range_params$stop)

    if (params$complete) {
      if (is_range_start_behind_first(range_params)) {
        params <- increment_position_by_one(params, split)
        next
      }

      if (is_range_stop_ahead_of_last(range_params)) {
        params <- increment_position_by_one(params, split)
        next
      }
    }

    if (is_range_start_ahead_of_last(range_params)) {
      params <- increment_position_by_one(params, split)
      next
    }

    if (is_range_stop_behind_first(range_params)) {
      params <- increment_position_by_one(params, split)
      next
    }

    window_start <- locate_window_start(i_starts, params, range_params)
    window_stop <- locate_window_stop(i_stops, params, range_params)

    out <- slice_eval_assign(out, x, f, window_start, window_stop, params, ...)

    params <- increment_position_by_one(params, split)
  }

  out
}

loop_after_unbounded <- function(x, i, f, params, range_params, split, ...) {
  range_starts <- compute_range_starts(split$key, params$before)

  out <- vec_init(params$ptype, params$n_out)

  window_stop <- params$n_out

  while(params$position_index <= params$n_index) {
    i_current <- split$key[[params$position_index]]

    params$entry <- split$id[[params$position_index]]

    range_params$start <- range_starts[[params$position_index]]
    check_na_range(range_params$start, ".before")

    range_params$start_ahead <- is_range_start_ahead_of_current(i_current, range_params$start)

    if (params$complete) {
      if (is_range_start_behind_first(range_params)) {
        params <- increment_position_by_one(params, split)
        next
      }
    }

    if (is_range_start_ahead_of_last(range_params)) {
      params <- increment_position_by_one(params, split)
      next
    }

    window_start <- locate_window_start(i, params, range_params)

    out <- slice_eval_assign(out, x, f, window_start, window_stop, params, ...)

    params <- increment_position_by_one(params, split)
  }

  out
}

loop_before_unbounded <- function(x, i, f, params, range_params, split, ...) {
  range_stops <- compute_range_stops(split$key, params$after)

  out <- vec_init(params$ptype, params$n_out)

  window_start <- 1L

  while(params$position_index <= params$n_index) {
    i_current <- split$key[[params$position_index]]

    params$entry <- split$id[[params$position_index]]

    range_params$stop <- range_stops[[params$position_index]]
    check_na_range(range_params$stop, ".after")

    range_params$stop_behind <- is_range_stop_behind_current(i_current, range_params$stop)

    if (params$complete) {
      if (is_range_stop_ahead_of_last(range_params)) {
        params <- increment_position_by_one(params, split)
        next
      }
    }

    if (is_range_stop_behind_first(range_params)) {
      params <- increment_position_by_one(params, split)
      next
    }

    window_stop <- locate_window_stop(i, params, range_params)

    out <- slice_eval_assign(out, x, f, window_start, window_stop, params, ...)

    params <- increment_position_by_one(params, split)
  }

  out
}

loop_double_unbounded <- function(x, f, params, ...) {
  out <- vec_init(params$ptype, params$n_out)

  window_start <- 1L
  window_stop <- params$n_out

  params$entry <- seq(window_start, window_stop)

  out <- slice_eval_assign(out, x, f, window_start, window_stop, params, ...)

  out
}

# ------------------------------------------------------------------------------

# Conceptually there are 4 ways to get out of bounds, and in these cases no
# evalution of the function should be made, and the parameters should be
# incremented by 1, not by the step value.

# 1. Start of the window is past the last data point
# slide(1:5, ~.x, .before = -1, .after = 1)
# 1 2 3 4 5 . . .
# . . . . . | - |
#           ^
#           |- Start of window outside range

is_start_ahead_of_last <- function(start, last, start_ahead) {
  start_ahead && vec_gt(start, last)
}

# 2. End of the window is before the first data point
# slide(1:5, ~.x, .before = 1, .after = -1)
# . . . 1 2 3 4 5
# | - | . . . . .
#     ^
#     |- End of window outside range

is_stop_behind_first <- function(stop, first, stop_behind) {
  stop_behind && vec_lt(stop, first)
}

# 3. Start of the window is before the first data point, and `.complete = TRUE`
# slide(1:5, ~.x, .before = 1, .complete = TRUE)
# . 1 2 3 4 5 . .
# | - | . . . . .
# ^
# |- Start of window outside range

is_start_behind_first <- function(start, first) {
  vec_lt(start, first)
}

# 4. End of the window is after the last data point, and `.complete = TRUE`
# slide(1:5, ~.x, .after = 1, .complete = TRUE)
# 1 2 3 4 5 . . .
# . . . | - | . .
#           ^
#           |- End of window outside range

is_stop_ahead_of_last <- function(stop, last) {
  vec_gt(stop, last)
}

# ------------------------------------------------------------------------------

is_range_start_ahead_of_last <- function(range_params) {
  is_start_ahead_of_last(range_params$start, range_params$start_last, range_params$start_ahead)
}

is_range_stop_behind_first <- function(range_params) {
  is_stop_behind_first(range_params$stop, range_params$stop_first, range_params$stop_behind)
}

is_range_start_behind_first <- function(range_params) {
  is_start_behind_first(range_params$start, range_params$start_first)
}

is_range_stop_ahead_of_last <- function(range_params) {
  is_stop_ahead_of_last(range_params$stop, range_params$stop_last)
}

# ------------------------------------------------------------------------------

increment_position_by_one <- function(params, split) {
  params$position_out <- params$position_out + split$sizes[[params$position_index]]
  params$position_index <- params$position_index + 1L
  params
}

# ------------------------------------------------------------------------------
# Should only ever pass objects of size 1 through here

vec_gt <- function(x, y) {
  vec_compare(x, y) > 0L
}

vec_gte <- function(x, y) {
  vec_compare(x, y) >= 0L
}

vec_lt <- function(x, y) {
  vec_compare(x, y) < 0L
}

vec_lte <- function(x, y) {
  vec_compare(x, y) <= 0L
}

# ------------------------------------------------------------------------------

slice_eval_assign <- function(out, x, f, window_start, window_stop, params, ...) {
  slice <- vec_slice(x, seq2(window_start, window_stop))

  elt <- f(slice, ...)

  if (params$constrain) {
    elt <- vec_cast(elt, params$ptype)

    if (vec_size(elt) != 1L) {
      abort(sprintf("The size of each result of `.f` must be size 1. Iteration %i was size %i.", params$position_index, vec_size(elt)))
    }

    out <- vec_assign(out, params$entry, elt)
  } else {
    for (i in params$entry) {
      out[[i]] <- elt
    }
  }

  out
}

# ------------------------------------------------------------------------------

slide_index <- function(.x,
                        .i,
                        .f,
                        ...,
                        .before = 0L,
                        .after = 0L,
                        .complete = FALSE
                        ) {
  slide_index_impl(
    .x,
    .i,
    .f,
    ...,
    .before = .before,
    .after = .after,
    .complete = .complete,
    .constrain = FALSE,
    .ptype = list()
  )
}
