glubort <- function (..., .sep = "", .envir = parent.frame()) {
  abort(glue::glue(..., .sep = .sep, .envir = .envir))
}

collapse_and_trim <- function(x) {
  glue::glue_collapse(x, sep = ", ", width = 30L)
}

is_unbounded <- function(x) {
  is.infinite(x) && x == Inf
}

check_all_size_one <- function(out) {
  size <- vec_size_common(!!!out)

  if (size != 1L) {
    sizes <- vapply(out, vec_size, integer(1))
    iteration <- which(sizes != 1L)[[1L]]
    bad_size <- sizes[[iteration]]
    stop_not_all_size_one(iteration, bad_size)
  }

  invisible(out)
}

check_not_na <- function(x, what) {
  na <- vec_equal_na(x)

  if (any(na)) {
    at <- which(na)
    at <- collapse_and_trim(at)
    glubort(
      "{what} cannot have `NA` values, ",
      "which were found at location(s): {at}."
    )
  }

  invisible(x)
}

check_ascending <- function(x, what) {
  order <- vec_order(x, "asc")

  if (is.unsorted(order)) {
    at <- which(diff(order) < 0L)
    at <- collapse_and_trim(at)
    glubort(
      "{what} must be in ascending order. ",
      "At the following locations, it is not: {at}."
    )
  }

  invisible(x)
}

check_is_list <- function(.l) {
  if (!is.list(.l)) {
    abort(paste0("`.l` must be a list, not ", vec_ptype_full(.l), "."))
  }

  invisible(.l)
}

stop_not_all_size_one <- function(iteration, size) {
  glubort("In iteration {iteration}, the result of `.f` had size {size}, not 1.")
}

# Thrown to here from C
stop_range_start_past_stop <- function(starts, stops) {
  start_after_stop <- vec_compare(starts, stops) == 1L

  at <- which(start_after_stop)
  at <- collapse_and_trim(at)

  msg <- paste0(
    "In the ranges generated by `.before` and `.after`, ",
    "the start of the range is after the end of the range at location(s): {at}."
  )

  glubort(msg)
}

compute_size <- function(x, type) {
  SLIDE <- -1L
  PSLIDE_EMPTY <- 0L

  if (type == SLIDE) {
    vec_size(x)
  } else if (type == PSLIDE_EMPTY) {
    0L
  } else {
    vec_size(x[[1L]])
  }
}
