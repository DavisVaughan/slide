slide_index_common <- function(x,
                               i,
                               f_call,
                               before,
                               after,
                               complete,
                               constrain,
                               ptype,
                               env,
                               type) {
  vec_assert(i)

  out_size <- compute_size(x, type)

  check_index_size(out_size, i)
  check_not_na(i, "`.i`")
  check_index_ascending(i)

  # Early exit if empty input
  # (but after the index size check)
  if (out_size == 0L) {
    return(vec_init(ptype, 0L))
  }

  before <- check_before(before)
  after <- check_after(after)
  complete <- check_complete(complete)

  # Compute unique values of `i` to avoid repeated evaluations of `.f`
  split <- vec_split_id(i)
  i <- split$key

  # `indices` helps us map back to `.x`
  # For `slide_index()` this is both `out_indices` and `window_indices`
  indices <- split$id

  range <- compute_ranges(i, before, after)
  i <- range$i
  starts <- range$starts
  stops <- range$stops

  params <- list(
    type,
    constrain,
    complete,
    out_size
  )

  .Call(
    slide_index_common_impl,
    x,
    i,
    starts,
    stops,
    f_call,
    ptype,
    env,
    indices,
    params
  )
}

# ------------------------------------------------------------------------------

compute_ranges <- function(i, before, after, start_unbounded, stop_unbounded) {
  start_unbounded <- is_unbounded(before)
  stop_unbounded <- is_unbounded(after)

  # Setting to `NULL`, as that is what the C level new_range_info() expects
  # for unbounded start / stop ranges
  if (start_unbounded) {
    starts <- NULL
  } else {
    starts <- compute_range_starts(i, before)
  }

  if (stop_unbounded) {
    stops <- NULL
  } else {
    stops <- compute_range_stops(i, after)
  }

  ptype <- vec_ptype_common(i, starts, stops)

  if (!start_unbounded) {
    starts <- vec_cast(starts, ptype)
    starts <- vec_proxy_compare(starts)
  }

  if (!stop_unbounded) {
    stops <- vec_cast(stops, ptype)
    stops <- vec_proxy_compare(stops)
  }

  i <- vec_cast(i, ptype)
  i <- vec_proxy_compare(i)

  list(i = i, starts = starts, stops = stops)
}

compute_range_starts <- function(i, before) {
  if (is_function(before)) {
    out <- before(i)
    check_ascending(out, "The range generated by `.before`")
    check_range_size(out, i, ".before")
  } else {
    out <- i - before
  }

  check_not_na(out, "The range generated by `.before`")

  out
}

compute_range_stops <- function(i, after) {
  if (is_function(after)) {
    out <- after(i)
    check_ascending(out, "The range generated by `.after`")
    check_range_size(out, i, ".after")
  } else {
    out <- i + after
  }

  check_not_na(out, "The range generated by `.after`")

  out
}

check_range_size <- function(x, i, arg) {
  size_x <- vec_size(x)
  size_i <- vec_size(i)

  if (size_x != size_i) {
    glubort(
      "The range generated by `{arg}` has size {size_x}, ",
      "but must have the same size as the unique values of `.i`, {size_i}."
    )
  }

  invisible(x)
}

# ------------------------------------------------------------------------------

check_index_size <- function(n, i) {
  n_i <- vec_size(i)

  if (n != n_i) {
    glubort("The size of `.x` ({n}) and `.i` ({n_i}) must be the same.")
  }

  invisible()
}

check_index_ascending <- function(x) {
  order <- vec_order(x, "asc")

  if (is.unsorted(order)) {
    at <- which(diff(order) < 0L)
    at <- collapse_and_trim(at)
    glubort(
      "The `.i`ndex must be in ascending order. ",
      "At the following locations, it is not: {at}."
    )
  }

  invisible(x)
}

# ------------------------------------------------------------------------------

check_before <- function(before) {
  if (is_unbounded(before)) {
    return(before)
  }

  if (is_formula(before, scoped = TRUE, lhs = FALSE)) {
    before <- as_function(before)
    return(before)
  }

  if (!is_function(before)) {
    vec_assert(before, size = 1L, arg = ".before")
  }

  before
}

check_after <- function(after) {
  if (is_unbounded(after)) {
    return(after)
  }

  if (is_formula(after, scoped = TRUE, lhs = FALSE)) {
    after <- as_function(after)
    return(after)
  }

  if (!is_function(after)) {
    vec_assert(after, size = 1L, arg = ".after")
  }

  after
}

check_complete <- function(complete) {
  complete <- vec_cast(complete, logical(), x_arg = ".complete")
  vec_assert(complete, size = 1L, arg = ".complete")
  complete
}
