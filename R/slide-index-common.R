slide_index_common <- function(x,
                               i,
                               f_call,
                               before,
                               after,
                               complete,
                               constrain,
                               ptype,
                               env,
                               type) {
  vec_assert(i)

  size <- compute_size(x, type)

  check_index_size(size, i)
  check_index_not_na(i)
  check_index_ascending(i)

  # Early exit if empty input
  # (but after the index size check)
  if (size == 0L) {
    return(vec_init(ptype, 0L))
  }

  before <- check_before(before)
  after <- check_after(after)
  complete <- check_complete(complete)

  split <- vec_split_id(i)

  i <- split$key
  out_indices <- split$id

  start_unbounded <- is_unbounded(before)
  stop_unbounded <- is_unbounded(after)

  range <- compute_range_info(i, before, after, start_unbounded, stop_unbounded)
  i <- range$i
  starts <- range$starts
  stops <- range$stops

  # Computed on `i` because `starts` could be NULL if unbounded() is set
  n_ranges <- vec_size(i)

  params <- list(
    type,
    constrain,
    size, # out_size
    complete,
    n_ranges
  )

  slide_between_base(
    x = x,
    i = i,
    starts = starts,
    stops = stops,
    f_call = f_call,
    ptype = ptype,
    env = env,
    out_indices = out_indices,
    window_indices = out_indices, # same as out_indices for slide_index
    params = params
  )
}

# ------------------------------------------------------------------------------

compute_range_info <- function(i, before, after, start_unbounded, stop_unbounded) {
  starts <- NULL
  if (!start_unbounded) {
    starts <- compute_range_starts(i, before)
  }

  stops <- NULL
  if (!stop_unbounded) {
    stops <- compute_range_stops(i, after)
  }

  ptype <- vec_ptype_common(i, starts, stops)

  if (!start_unbounded) {
    starts <- vec_cast(starts, ptype)
    starts <- vec_proxy_compare(starts)
  }

  if (!stop_unbounded) {
    stops <- vec_cast(stops, ptype)
    stops <- vec_proxy_compare(stops)
  }

  i <- vec_cast(i, ptype)
  i <- vec_proxy_compare(i)

  list(i = i, starts = starts, stops = stops)
}

compute_range_starts <- function(i, before) {
  if (is_function(before)) {
    out <- before(i)
    check_ascending(out, ".before")
    check_range_size(out, i, ".before")
  } else {
    out <- i - before
  }

  check_range_not_na(out, ".before")

  out
}

compute_range_stops <- function(i, after) {
  if (is_function(after)) {
    out <- after(i)
    check_ascending(out, ".after")
    check_range_size(out, i, ".after")
  } else {
    out <- i + after
  }

  check_range_not_na(out, ".after")

  out
}

check_ascending <- function(x, arg) {
  order <- vec_order(x, "asc")

  if (is.unsorted(order)) {
    at <- which(diff(order) < 0L)
    at <- collapse_and_trim(at)
    glubort(
      "The range generated by `{arg}` must be in ascending order. ",
      "At the following locations, it is not: {at}."
    )
  }

  invisible(x)
}

check_range_not_na <- function(x, arg) {
  na <- vec_equal_na(x)

  if (any(na)) {
    at <- which(na)
    at <- collapse_and_trim(at)
    glubort(
      "The range generated by `{arg}` cannot have `NA` values, ",
      "which were found at location(s): {at}."
    )
  }

  invisible(x)
}

check_range_size <- function(x, i, arg) {
  size_x <- vec_size(x)
  size_i <- vec_size(i)

  if (size_x != size_i) {
    glubort(
      "The range generated by `{arg}` has size {size_x}, ",
      "but must have the same size as the unique values of `.i`, {size_i}."
    )
  }

  invisible(x)
}

# ------------------------------------------------------------------------------

check_index_size <- function(n, i) {
  n_i <- vec_size(i)

  if (n != n_i) {
    glubort("The size of `.x` ({n}) and `.i` ({n_i}) must be the same.")
  }

  invisible()
}

check_index_ascending <- function(x) {
  order <- vec_order(x, "asc")

  if (is.unsorted(order)) {
    at <- which(diff(order) < 0L)
    at <- collapse_and_trim(at)
    glubort(
      "The `.i`ndex must be in ascending order. ",
      "At the following locations, it is not: {at}."
    )
  }

  invisible(x)
}

check_index_not_na <- function(i) {
  na <- vec_equal_na(i)

  if (any(na)) {
    at <- which(na)
    at <- collapse_and_trim(at)
    glubort("The `.i`ndex cannot have `NA` values, which were found at location(s): {at}.")
  }

  invisible(i)
}

check_before <- function(before) {
  if (is_unbounded(before)) {
    return(before)
  }

  if (is_formula(before, scoped = TRUE, lhs = FALSE)) {
    before <- as_function(before)
    return(before)
  }

  if (!is_function(before)) {
    vec_assert(before, size = 1L, arg = ".before")
  }

  before
}

check_after <- function(after) {
  if (is_unbounded(after)) {
    return(after)
  }

  if (is_formula(after, scoped = TRUE, lhs = FALSE)) {
    after <- as_function(after)
    return(after)
  }

  if (!is_function(after)) {
    vec_assert(after, size = 1L, arg = ".after")
  }

  after
}

check_complete <- function(complete) {
  complete <- vec_cast(complete, logical(), x_arg = ".complete")
  vec_assert(complete, size = 1L, arg = ".complete")
  complete
}
