slide_index_common <- function(x,
                               i,
                               f_call,
                               before,
                               after,
                               complete,
                               constrain,
                               ptype,
                               env,
                               type) {
  vec_assert(i)

  out_size <- compute_size(x, type)

  check_index_size(out_size, i)
  check_not_na(i, "`.i`")
  check_ascending(i, "The `.i`ndex")

  # Early exit if empty input
  # (but after the index size check)
  if (out_size == 0L) {
    return(vec_init(ptype, 0L))
  }

  check_before(before)
  check_after(after)
  complete <- check_complete(complete)

  # Compute unique values of `i` to avoid repeated evaluations of `.f`
  split <- vec_split_id(i)
  i <- split$key

  # `indices` helps us map back to `.x`
  # For `slide_index()` this is both `out_indices` and `window_indices`
  indices <- split$id

  range <- compute_ranges(i, before, after)
  i <- range$i
  starts <- range$starts
  stops <- range$stops

  params <- list(
    type,
    constrain,
    complete,
    out_size
  )

  .Call(
    slide_index_common_impl,
    x,
    i,
    starts,
    stops,
    f_call,
    ptype,
    env,
    indices,
    params
  )
}

# ------------------------------------------------------------------------------

compute_ranges <- function(i, before, after, start_unbounded, stop_unbounded) {
  start_unbounded <- is_unbounded(before)
  stop_unbounded <- is_unbounded(after)

  # Setting to `NULL`, as that is what the C level new_range_info() expects
  # for unbounded start / stop ranges
  if (start_unbounded) {
    starts <- NULL
  } else {
    starts <- compute_range_starts(i, before)
  }

  if (stop_unbounded) {
    stops <- NULL
  } else {
    stops <- compute_range_stops(i, after)
  }

  ptype <- vec_ptype_common(i, starts, stops)

  if (!start_unbounded) {
    starts <- vec_cast(starts, ptype)
    starts <- vec_proxy_compare(starts)
  }

  if (!stop_unbounded) {
    stops <- vec_cast(stops, ptype)
    stops <- vec_proxy_compare(stops)
  }

  i <- vec_cast(i, ptype)
  i <- vec_proxy_compare(i)

  list(i = i, starts = starts, stops = stops)
}

compute_range_starts <- function(i, before) {
  out <- i - before

  check_not_na(out, "The range generated by `.before`")

  out
}

compute_range_stops <- function(i, after) {
  out <- i + after

  check_not_na(out, "The range generated by `.after`")

  out
}

# ------------------------------------------------------------------------------

check_index_size <- function(n, i) {
  n_i <- vec_size(i)

  if (n != n_i) {
    glubort("The size of `.x` ({n}) and `.i` ({n_i}) must be the same.")
  }

  invisible()
}

# ------------------------------------------------------------------------------

check_before <- function(before) {
  if (is_unbounded(before)) {
    return(invisible(before))
  }

  vec_assert(before, size = 1L, arg = ".before")

  invisible(before)
}

check_after <- function(after) {
  if (is_unbounded(after)) {
    return(invisible(after))
  }

  vec_assert(after, size = 1L, arg = ".after")

  invisible(after)
}

check_complete <- function(complete) {
  complete <- vec_cast(complete, logical(), x_arg = ".complete")
  vec_assert(complete, size = 1L, arg = ".complete")
  complete
}
