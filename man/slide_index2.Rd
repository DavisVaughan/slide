% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/slide-index2.R, R/pslide-index.R
\name{slide_index2}
\alias{slide_index2}
\alias{slide_index2_vec}
\alias{slide_index2_dbl}
\alias{slide_index2_int}
\alias{slide_index2_lgl}
\alias{slide_index2_chr}
\alias{slide_index2_raw}
\alias{slide_index2_dfr}
\alias{slide_index2_dfc}
\alias{pslide_index}
\alias{pslide_index_vec}
\alias{pslide_index_dbl}
\alias{pslide_index_int}
\alias{pslide_index_lgl}
\alias{pslide_index_chr}
\alias{pslide_index_raw}
\alias{pslide_index_dfr}
\alias{pslide_index_dfc}
\title{Slide along multiples inputs simultaneously over an index}
\usage{
slide_index2(.x, .y, .i, .f, ..., .before = 0L, .after = 0L,
  .complete = FALSE)

slide_index2_vec(.x, .y, .i, .f, ..., .before = 0L, .after = 0L,
  .complete = FALSE, .ptype = list())

slide_index2_dbl(.x, .y, .i, .f, ..., .before = 0L, .after = 0L,
  .complete = FALSE)

slide_index2_int(.x, .y, .i, .f, ..., .before = 0L, .after = 0L,
  .complete = FALSE)

slide_index2_lgl(.x, .y, .i, .f, ..., .before = 0L, .after = 0L,
  .complete = FALSE)

slide_index2_chr(.x, .y, .i, .f, ..., .before = 0L, .after = 0L,
  .complete = FALSE)

slide_index2_raw(.x, .y, .i, .f, ..., .before = 0L, .after = 0L,
  .complete = FALSE)

slide_index2_dfr(.x, .y, .i, .f, ..., .before = 0L, .after = 0L,
  .complete = FALSE, .names_to = NULL, .name_repair = c("unique",
  "universal", "check_unique"))

slide_index2_dfc(.x, .y, .i, .f, ..., .before = 0L, .after = 0L,
  .complete = FALSE, .size = NULL, .name_repair = c("unique",
  "universal", "check_unique", "minimal"))

pslide_index(.l, .i, .f, ..., .before = 0L, .after = 0L,
  .complete = FALSE)

pslide_index_vec(.l, .i, .f, ..., .before = 0L, .after = 0L,
  .complete = FALSE, .ptype = list())

pslide_index_dbl(.l, .i, .f, ..., .before = 0L, .after = 0L,
  .complete = FALSE)

pslide_index_int(.l, .i, .f, ..., .before = 0L, .after = 0L,
  .complete = FALSE)

pslide_index_lgl(.l, .i, .f, ..., .before = 0L, .after = 0L,
  .complete = FALSE)

pslide_index_chr(.l, .i, .f, ..., .before = 0L, .after = 0L,
  .complete = FALSE)

pslide_index_raw(.l, .i, .f, ..., .before = 0L, .after = 0L,
  .complete = FALSE)

pslide_index_dfr(.l, .i, .f, ..., .before = 0L, .after = 0L,
  .complete = FALSE, .names_to = NULL, .name_repair = c("unique",
  "universal", "check_unique"))

pslide_index_dfc(.l, .i, .f, ..., .before = 0L, .after = 0L,
  .complete = FALSE, .size = NULL, .name_repair = c("unique",
  "universal", "check_unique", "minimal"))
}
\arguments{
\item{.x, .y}{\code{[vector]}

Vectors to iterate over. Vectors of size 1 will be recycled.}

\item{.i}{\code{[vector]}

The index vector that determines the window sizes. The lower bound
of the window range will be computed as \code{.i - .before}, and the upper
bound will be \code{.i + .after}. It is faily common to supply a date vector
as the index, but not required.}

\item{.f}{\code{[function / formula]}

If a \strong{function}, it is used as is.

If a \strong{formula}, e.g. \code{~ .x + 2}, it is converted to a function with up
to two arguments: \code{.x} (single argument) or \code{.x} and \code{.y} (two arguments).
The \code{.} placeholder can be used instead of \code{.x}. This allows you to
create very compact anonymous functions with up to two inputs.}

\item{...}{Additional arguments passed on to the mapped function.}

\item{.before}{\code{[vector(1) / Inf]}

The number of values \emph{before} the current element of \code{.i} to include in the
sliding window. Set to \code{Inf} to select all elements before the
current element, constructing a cumulative window. A negative value is
allowed, and allows you to "look forward" as well.

For \code{slide_index()}, this can be any object that can be subtracted from
\code{.i} with \code{-}. One common use case is to set this to a lubridate period,
such as \code{\link[lubridate:weeks]{lubridate::weeks()}}.}

\item{.after}{\code{[vector(1) / Inf]}

The number of values \emph{after} the current element of \code{.i} to include in the
sliding window. Set to \code{Inf} to select all elements after the
current position, constructing the reverse of a cumulative window, where
you start with as many elements as possible and decrease the amount as you
move through \code{.x}. A negative value is allowed, and allows you to "look
backward" as well.

For \code{slide_index()}, this can be any object that can be added to
\code{.i} with \code{+}. One common use case is to set this to a lubridate period,
such as \code{\link[lubridate:weeks]{lubridate::weeks()}}.}

\item{.complete}{\code{[logical(1)]}

Should the sliding be restricted to complete windows only? If \code{FALSE},
the default, then partial computations will be allowed.}

\item{.ptype}{\code{[vector]}

The prototype corresponding to the type of the output. Defaults to
a \code{list()}.}

\item{.names_to}{Optionally, the name of a column where the names
of \code{...} arguments are copied. These names are useful to identify
which row comes from which input. If supplied and \code{...} is not named,
an integer column is used to identify the rows.}

\item{.name_repair}{One of \code{"unique"}, \code{"universal"}, or
\code{"check_unique"}. See \code{\link[=vec_as_names]{vec_as_names()}} for the meaning of these
options.

With \code{vec_rbind()}, the repair function is applied to all inputs
separately. This is because \code{vec_rbind()} needs to align their
columns before binding the rows, and thus needs all inputs to
have unique names. On the other hand, \code{vec_cbind()} applies the
repair function after all inputs have been concatenated together
in a final data frame. Hence \code{vec_cbind()} allows the more
permissive minimal names repair.}

\item{.size}{If, \code{NULL}, the default, will determine the number of
rows in \code{vec_cbind()} output by using the standard recycling rules.

Alternatively, specify the desired number of rows, and any inputs
of length 1 will be recycled appropriately.}

\item{.l}{\code{[list]}

A list of vectors. The length of \code{.l} determines the
number of arguments that \code{.f} will be called with. If \code{.l} has names,
they will be used as named arguments to \code{.f}. Elements of \code{.l} with size
1 will be recycled.}
}
\description{
\code{slide_index2()} and \code{pslide_index()} represent the combination
of \code{\link[=slide2]{slide2()}} and \code{\link[=pslide]{pslide()}} with \code{\link[=slide_index]{slide_index()}}, allowing you to iterate
over multiple vectors at once, while respecting an \code{.i}-ndex.
}
\section{\code{.i} Details}{


There are 3 restrictions on \code{.i}:
\itemize{
\item The size of \code{.i} must match the size of \code{.x}, \code{.i} will not be recycled.
\item \code{.i} must be an \emph{increasing} vector, but duplicate values
are allowed.
\item \code{.i} is not allowed to have missing values.
}

The ranges computed from \code{.i - .before} and \code{.i + .after} have the same
restrictions as the three mentioned above.
}

\examples{
# Notice that `i` is an irregular index!
x <- 1:5
y <- 6:10
i <- as.Date("2019-08-15") + c(0:1, 4, 6, 7)

# When we slide over `i` looking back 1 day, the irregularity is respected.
# When there is a gap in dates, only 2 values are returned (one from
# `x` and one from `y`), otherwise, 4 values are returned.
slide_index2(x, y, i, ~c(.x, .y), .before = 1)

}
\seealso{
\code{\link[=slide2]{slide2()}}, \code{\link[=slide_index]{slide_index()}}
}
