% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/slide.R
\name{slide}
\alias{slide}
\alias{slide_vec}
\alias{slide_dbl}
\alias{slide_int}
\alias{slide_lgl}
\alias{slide_chr}
\alias{slide_raw}
\alias{slide_dfr}
\alias{slide_dfc}
\title{Slide}
\usage{
slide(.x, .f, ..., .before = 0L, .after = 0L, .step = 1L,
  .complete = FALSE)

slide_vec(.x, .f, ..., .before = 0L, .after = 0L, .step = 1L,
  .complete = FALSE, .ptype = list())

slide_dbl(.x, .f, ..., .before = 0L, .after = 0L, .step = 1L,
  .complete = FALSE)

slide_int(.x, .f, ..., .before = 0L, .after = 0L, .step = 1L,
  .complete = FALSE)

slide_lgl(.x, .f, ..., .before = 0L, .after = 0L, .step = 1L,
  .complete = FALSE)

slide_chr(.x, .f, ..., .before = 0L, .after = 0L, .step = 1L,
  .complete = FALSE)

slide_raw(.x, .f, ..., .before = 0L, .after = 0L, .step = 1L,
  .complete = FALSE)

slide_dfr(.x, .f, ..., .before = 0L, .after = 0L, .step = 1L,
  .complete = FALSE, .names_to = NULL, .name_repair = c("unique",
  "universal", "check_unique"))

slide_dfc(.x, .f, ..., .before = 0L, .after = 0L, .step = 1L,
  .complete = FALSE, .size = NULL, .name_repair = c("unique",
  "universal", "check_unique", "minimal"))
}
\arguments{
\item{.x}{\code{[vector]}

The vector to iterate over and apply \code{.f} to.}

\item{.f}{\code{[function / formula]}

If a \strong{function}, it is used as is.

If a \strong{formula}, e.g. \code{~ .x + 2}, it is converted to a function with up
to two arguments: \code{.x} (single argument) or \code{.x} and \code{.y} (two arguments).
The \code{.} placeholder can be used instead of \code{.x}. This allows you to
create very compact anonymous functions with up to two inputs.}

\item{...}{Additional arguments passed on to the mapped function.}

\item{.before}{\code{[integer(1) / Inf]}

The number of values \emph{before} the current element to include in the sliding
window. Set to \code{Inf} to select all elements before the current
position, constructing a cumulative window. A negative value is allowed,
and allows you to "look forward" as well.}

\item{.after}{\code{[integer(1) / Inf]}

The number of values \emph{after} the current element to include in the
sliding window. Set to \code{Inf} to select all elements after the
current position, constructing the reverse of a cumulative window, where
you start with as many elements as possible and decrease the amount as
you move through \code{.x}. A negative value is allowed, and allows you to
"look backward" as well.}

\item{.step}{\code{[positive integer(1)]}

The number of elements to shift the window forward between function calls.}

\item{.complete}{\code{[logical(1)]}

Should the sliding be restricted to complete windows only? If \code{FALSE},
the default, then partial computations will be allowed.}

\item{.ptype}{\code{[vector]}

The prototype corresponding to the type of the output. Defaults to
a \code{list()}.}

\item{.names_to}{Optionally, the name of a column where the names
of \code{...} arguments are copied. These names are useful to identify
which row comes from which input. If supplied and \code{...} is not named,
an integer column is used to identify the rows.}

\item{.name_repair}{One of \code{"unique"}, \code{"universal"}, or
\code{"check_unique"}. See \code{\link[=vec_as_names]{vec_as_names()}} for the meaning of these
options.

With \code{vec_rbind()}, the repair function is applied to all inputs
separately. This is because \code{vec_rbind()} needs to align their
columns before binding the rows, and thus needs all inputs to
have unique names. On the other hand, \code{vec_cbind()} applies the
repair function after all inputs have been concatenated together
in a final data frame. Hence \code{vec_cbind()} allows the more
permissive minimal names repair.}

\item{.size}{If, \code{NULL}, the default, will determine the number of
rows in \code{vec_cbind()} output by using the standard recycling rules.

Alternatively, specify the desired number of rows, and any inputs
of length 1 will be recycled appropriately.}
}
\description{
\code{slide()} iterates through \code{.x} using a sliding window, applying \code{.f} to each
sub-window of \code{.x}.
}
\details{
Unlike \code{lapply()} or \code{purrr::map()}, which construct calls
like \code{.f(.x[[i]], ...)}, the equivalent with \code{slide()}
looks like \code{.f(vec_slice(.x, i), ...)} which is approximately
\code{.f(.x[i], ...)} except in the case of data frames or arrays,
which are iterated over row-wise.

If \code{.x} has names, then the output will preserve those names.

Using \code{\link[vctrs:vec_cast]{vctrs::vec_cast()}}, the output of \code{.f} will be automatically cast
to the type required by the version of \code{slide_*()} being used.
}
\section{Invariants}{

\itemize{
\item \code{vec_size(.x) == vec_size(slide(.x, .f))}
\item \code{vec_size(slide_vec(.x, .f)[[i]]) == 1L}
}
}

\examples{
# The defaults work similarly to `map()`
slide(1:5, ~.x)

# Use `.before`, `.after`, and `.step` to control the window
slide(1:5, ~.x, .before = 1)

# This can be used for rolling means
slide_dbl(rnorm(5), mean, .before = 2)

# Or more flexible rolling operations
slide(rnorm(5), ~ .x - mean(.x), .before = 2)

# `.after` allows you to "align to the left" rather than the right
slide(1:5, ~.x, .after = 2)

# And a mixture of `.before` and `.after`
# allows you complete control over the exact alignment.
# Below, "center alignment" is used.
slide(1:5, ~.x, .before = 1, .after = 1)

# The `.step` controls how the window is shifted along `.x`,
# allowing you to "skip" iterations if you only need a less granular result
slide(1:10, ~.x, .before = 2, .step = 3)

# `.complete` controls whether or not partial results are computed.
# By default, they are, but setting `.complete = TRUE` restricts
# `slide()` to only evaluate the function where a complete window exists.
slide(1:5, ~.x, .before = 2, .after = 1)
slide(1:5, ~.x, .before = 2, .after = 1, .complete = TRUE)

# ---------------------------------------------------------------------------
# Data frames

# Data frames are iterated over rowwise
mtcars_rowwise <- slide(mtcars, ~.x)
mtcars_rowwise[1:3]

# This means that any column name is easily accessible
slide_dbl(mtcars, ~.x$mpg + .x$cyl)

# More advanced rowwise iteration is available as well by using the
# other arguments
mtcars_rowwise_window <- slide(mtcars, ~.x, .before = 1, .after = 1)
mtcars_rowwise_window[1:3]

# ---------------------------------------------------------------------------
# Cumulative sliding

# Using the special cased value, `Inf`, you can ask `slide()` to pin the
# start of the sliding window to the first element, effectively creating
# a cumulative window
slide(1:5, ~.x, .before = Inf)

# Same with `.after`, this creates a window where you start with all of the
# elements, but decrease the total number over each iteration
slide(1:5, ~.x, .after = Inf)

# ---------------------------------------------------------------------------
# Negative `.before` / `.after`

# `.before` is allowed to be negative, allowing you to "look forward" in
# your vector. Note that `abs(.before) <= .after` must hold if `.before` is
# negative. In this example, we look forward to elements in locations 2 and 3
# but place the result in position 1 in the output.
slide(1:5, ~.x, .before = -1, .after = 2)

# `.after` can be negative as well to "look backwards"
slide(1:5, ~.x, .before = 2, .after = -1)

}
\seealso{
\code{\link[=slide2]{slide2()}}, \code{\link[=slide_index]{slide_index()}}
}
