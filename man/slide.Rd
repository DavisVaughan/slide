% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/slide.R
\name{slide}
\alias{slide}
\alias{slide_vec}
\alias{slide_dbl}
\alias{slide_dfr}
\title{Slide}
\usage{
slide(.x, .f, ..., .before = 0L, .after = 0L, .step = 1L,
  .offset = NULL, .complete = FALSE, .dir = "forward")

slide_vec(.x, .f, ..., .before = 0L, .after = 0L, .step = 1L,
  .offset = NULL, .complete = FALSE, .dir = "forward",
  .ptype = list())

slide_dbl(.x, .f, ..., .before = 0L, .after = 0L, .step = 1L,
  .offset = NULL, .complete = FALSE, .dir = "forward")

slide_dfr(.x, .f, ..., .before = 0L, .after = 0L, .step = 1L,
  .offset = NULL, .complete = FALSE, .dir = "forward",
  .names_to = NULL, .name_repair = c("unique", "universal",
  "check_unique"))
}
\arguments{
\item{.x}{\code{[vector]} The vector to iterate over.}

\item{.f}{\code{[function / formula]}

If a \strong{function}, it is used as is.

If a \strong{formula}, e.g. \code{~ .x + 2}, it is converted to a function with up
to two arguments: \code{.x} (single argument) or \code{.x} and \code{.y} (two arguments).
The \code{.} placeholder can be used instead of \code{.x}. This allows you to
create very compact anonymous functions with up to two inputs.}

\item{...}{Additional arguments passed on to the mapped function.}

\item{.before}{\code{[integer]} The number of values \emph{before} the
current element to include in the sliding window. Set to \code{unbounded()}
to select all elements before the current position. A negative value
is allowed, and allows you to "look forward" as well.}

\item{.after}{\code{[integer]} The number of values \emph{after} the
current element to include in the sliding window. Set to \code{unbounded()}
to select all elements after the current position. A negative value
is allowed, and allows you to "look backward" as well.}

\item{.step}{\code{[positive integer]} The number of elements to shift the
window forward (or backward, depending on \code{.dir}) between function calls.}

\item{.offset}{\code{[NULL / positive integer]} An offset from the beginning
(or end, depending on \code{.dir}) of \code{.x} to place the first element in
the output vector. If \code{NULL}, this is computed automatically as the first
location where a complete sliding window can be generated.}

\item{.complete}{\code{[logical]} Should the sliding be restricted to complete
windows only? If \code{FALSE}, the default, then partial computations will be
allowed.}

\item{.dir}{\code{["forward", "backward"]} The direction to slide.}

\item{.ptype}{\code{[vector]} The prototype corresponding to the type of the
output. Defaults to a \code{list()}.}

\item{.names_to}{Optionally, the name of a column where the names
of \code{...} arguments are copied. These names are useful to identify
which row comes from which input. If supplied and \code{...} is not named,
an integer column is used to identify the rows.}

\item{.name_repair}{One of \code{"unique"}, \code{"universal"}, or
\code{"check_unique"}. See \code{\link[=vec_as_names]{vec_as_names()}} for the meaning of these
options.

With \code{vec_rbind()}, the repair function is applied to all inputs
separately. This is because \code{vec_rbind()} needs to align their
columns before binding the rows, and thus needs all inputs to
have unique names. On the other hand, \code{vec_cbind()} applies the
repair function after all inputs have been concatenated together
in a final data frame. Hence \code{vec_cbind()} allows the more
permissive minimal names repair.}
}
\description{
\code{slide()} iterates through \code{.x} using a sliding window, applying \code{.f} to each
sub-window of \code{.x}. In slurrr, \code{slide()} is the most generic of the iterating
functions, and \code{tile()} and \code{stretch()} are just special cases of \code{slide()}.
}
\details{
Unlike \code{lapply()} / \code{purrr::map()}, which construct calls
like \code{.f(.x[[i]], ...)}, the equivalent with \code{slide()}
looks like \code{.f(vec_slice(.x, i), ...)} which is approximately
\code{.f(.x[i], ...)} except in the case of data frames or arrays,
which are iterated over row-wise.

If \code{.x} has names, then the output will preserve those names.

Using \code{\link[vctrs:vec_cast]{vctrs::vec_cast()}}, the output of \code{.f} will be automatically cast
to the type required by the version of \code{slide_*()} being used.
}
\section{Invariants}{

\itemize{
\item \code{vec_size(.x) == vec_size(slide(.x, .f))}
\item \code{vec_size(slide_vec(.x, .f)[[i]]) == 1L}
}
}

\examples{

# The defaults work similarly to `map()`
slide(1:10, ~.x)

# Use `.before`, `.after`, and `.step` to control the window
slide(1:10, ~.x, .before = 1)

# This can be used for rolling means
slide_dbl(rnorm(10), mean, .before = 2)

# Or more flexible rolling operations
slide(rnorm(10), ~ .x - mean(.x), .before = 2)

# `.after` allows you to "align to the left" rather than the right
slide(1:10, ~.x, .after = 2)

# And a mixture of `.before` and `.after`
# allows you complete control over the exact alignment.
# Below, "center alignment" is used.
slide(1:10, ~.x, .before = 1, .after = 1)

# The `.step` controls how the window is shifted along `.x`,
# allowing you to "skip" iterations if you only need a less granular result
slide(1:10, ~.x, .before = 2, .step = 3)

# The `.offset` let's you shift the initial placement of results
# in the output. In this example, the offset is set to place the first
# element at position 3, even though results could have been computed and
# placed at locations 1 and 2.
slide(1:5, ~.x, .before = 1, .offset = 2)
slide(1:5, ~.x, .before = 1)

# `.complete` controls whether or not partial results are computed.
# By default, they are, but setting `.complete = TRUE` restricts
# `slide()` to only evaluate the function where a complete window exists.
slide(1:5, ~.x, .before = 2, .after = 1)
slide(1:5, ~.x, .before = 2, .after = 1, .complete = TRUE)

# `.dir` controls the actual direction of sliding, and controls the
# order in which the sub-window of `.x` is actually sliced out (notice
# the elements in the backwards example are `c(5, 4)` not `c(4, 5)`).
slide(1:5, ~.x, .before = 1, .step = 2)
slide(1:5, ~.x, .before = 1, .step = 2, .dir = "backward")

# ---------------------------------------------------------------------------
# Data frames

# Data frames are iterated over rowwise
slide(mtcars, ~.x)

# This means that any column name is easily accessible
slide_dbl(mtcars, ~.x$mpg + .x$cyl)

# More advanced rowwise iteration is available as well by using the
# other arguments
slide(mtcars, ~.x, .before = 1, .after = 1)

# ---------------------------------------------------------------------------
# Cumulative sliding

# Using the sentinel value, `unbounded()`, you can ask `slide()` to pin the
# start of the sliding window to the first element, effectively creating
# a cumulative window
slide(1:5, ~.x, .before = unbounded())

# Same with `.after`, this creates a window where you start with all of the
# elements, but decrease the total number over each iteration
slide(1:5, ~.x, .after = unbounded())

# ---------------------------------------------------------------------------
# Negative `.before` / `.after`

# `.before` is allowed to be negative, allowing you to "look forward" in
# your vector. Note that `abs(.before) <= .after` must hold if `.before` is
# negative. In this example, we look forward to elements in locations 2 and 3
# but place the result in position 1 in the output.
slide(1:5, ~.x, .before = -1, .after = 2)

# `.after` can be negative as well to "look backwards"
slide(1:5, ~.x, .before = 2, .after = -1)

}
