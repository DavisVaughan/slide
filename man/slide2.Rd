% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pslide.R, R/slide2.R
\name{pslide}
\alias{pslide}
\alias{pslide_vec}
\alias{pslide_dbl}
\alias{pslide_dfr}
\alias{slide2}
\alias{slide2_vec}
\alias{slide2_dbl}
\title{Slide over multiple inputs simultaneously}
\usage{
pslide(.l, .f, ..., .before = 0L, .after = 0L, .step = 1L,
  .offset = NULL, .complete = FALSE, .dir = "forward")

pslide_vec(.l, .f, ..., .before = 0L, .after = 0L, .step = 1L,
  .offset = NULL, .complete = FALSE, .dir = "forward",
  .ptype = list())

pslide_dbl(.l, .f, ..., .before = 0L, .after = 0L, .step = 1L,
  .offset = NULL, .complete = FALSE, .dir = "forward")

pslide_dfr(.l, .f, ..., .before = 0L, .after = 0L, .step = 1L,
  .offset = NULL, .complete = FALSE, .dir = "forward",
  .names_to = NULL, .name_repair = c("unique", "universal",
  "check_unique"))

slide2(.x, .y, .f, ..., .before = 0L, .after = 0L, .step = 1L,
  .offset = NULL, .complete = FALSE, .dir = "forward")

slide2_vec(.x, .y, .f, ..., .before = 0L, .after = 0L, .step = 1L,
  .offset = NULL, .complete = FALSE, .dir = "forward",
  .ptype = list())

slide2_dbl(.x, .y, .f, ..., .before = 0L, .after = 0L, .step = 1L,
  .offset = NULL, .complete = FALSE, .dir = "forward")
}
\arguments{
\item{.l}{\code{[list]} A list of vectors. The length of \code{.l} determines the
number of arguments that \code{.f} will be called with. If \code{.l} has names,
they will be used as named arguments to \code{.f}.}

\item{.f}{\code{[function / formula]}

If a \strong{function}, it is used as is.

If a \strong{formula}, e.g. \code{~ .x + 2}, it is converted to a function with up
to two arguments: \code{.x} (single argument) or \code{.x} and \code{.y} (two arguments).
The \code{.} placeholder can be used instead of \code{.x}. This allows you to
create very compact anonymous functions with up to two inputs.}

\item{...}{Data frames or vectors.

\code{vec_rbind()} ignores names unless \code{.names_to} is supplied.
\code{vec_cbind()} creates packed data frame columns with named
inputs.

\code{NULL} inputs are silently ignored. Empty (e.g. zero row) inputs
will not appear in the output, but will affect the derived \code{.ptype}.}

\item{.before}{\code{[integer]} The number of values \emph{before} the
current element to include in the sliding window. Set to \code{unbounded()}
to select all elements before the current position. A negative value
is allowed, and allows you to "look forward" as well.}

\item{.after}{\code{[integer]} The number of values \emph{after} the
current element to include in the sliding window. Set to \code{unbounded()}
to select all elements after the current position. A negative value
is allowed, and allows you to "look backward" as well.}

\item{.step}{\code{[positive integer]} The number of elements to shift the
window forward (or backward, depending on \code{.dir}) between function calls.}

\item{.offset}{\code{[NULL / positive integer]} An offset from the beginning
(or end, depending on \code{.dir}) of \code{.x} to place the first element in
the output vector. If \code{NULL}, this is computed automatically as the first
location where a complete sliding window can be generated.}

\item{.complete}{\code{[logical]} Should the sliding be restricted to complete
windows only? If \code{FALSE}, the default, then partial computations will be
allowed.}

\item{.dir}{\code{["forward", "backward"]} The direction to slide.}

\item{.ptype}{If \code{NULL}, the default, the output type is determined by
computing the common type across all elements of \code{...}.

Alternatively, you can supply \code{.ptype} to give the output known type.
If \code{getOption("vctrs.no_guessing")} is \code{TRUE} you must supply this value:
this is a convenient way to make production code demand fixed types.}

\item{.names_to}{Optionally, the name of a column where the names
of \code{...} arguments are copied. These names are useful to identify
which row comes from which input. If supplied and \code{...} is not named,
an integer column is used to identify the rows.}

\item{.name_repair}{One of \code{"unique"}, \code{"universal"}, or
\code{"check_unique"}. See \code{\link[=vec_as_names]{vec_as_names()}} for the meaning of these
options.

With \code{vec_rbind()}, the repair function is applied to all inputs
separately. This is because \code{vec_rbind()} needs to align their
columns before binding the rows, and thus needs all inputs to
have unique names. On the other hand, \code{vec_cbind()} applies the
repair function after all inputs have been concatenated together
in a final data frame. Hence \code{vec_cbind()} allows the more
permissive minimal names repair.}

\item{.x, .y}{\code{[vector]} Vectors to iterate over. Vectors of size 1 will
be recycled.}
}
\description{
These are variants of \code{\link[=slide]{slide()}} that iterate over multiple inputs in
parallel. They are parallel in the sense that each input is processed in
parallel with the others, not in the sense of multicore computing. These
functions work similarly to \code{map2()} and \code{pmap()} from purrr.
}
