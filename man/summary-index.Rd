% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/summary-index.R
\name{summary-index}
\alias{summary-index}
\alias{slide_index_sum}
\alias{slide_index_prod}
\alias{slide_index_mean}
\alias{slide_index_min}
\alias{slide_index_max}
\title{Specialized sliding functions relative to an index}
\usage{
slide_index_sum(x, i, before = 0L, after = 0L, complete = FALSE, na_rm = FALSE)

slide_index_prod(
  x,
  i,
  before = 0L,
  after = 0L,
  complete = FALSE,
  na_rm = FALSE
)

slide_index_mean(
  x,
  i,
  before = 0L,
  after = 0L,
  complete = FALSE,
  na_rm = FALSE
)

slide_index_min(x, i, before = 0L, after = 0L, complete = FALSE, na_rm = FALSE)

slide_index_max(x, i, before = 0L, after = 0L, complete = FALSE, na_rm = FALSE)
}
\arguments{
\item{x}{\verb{[double]}

A vector to compute the sliding function on. If not already a double
vector, will be cast to one with \code{\link[vctrs:vec_cast]{vctrs::vec_cast()}}.}

\item{i}{\verb{[vector]}

The index vector that determines the window sizes. The lower bound
of the window range will be computed as \code{.i - .before}, and the upper
bound as \code{.i + .after}. It is fairly common to supply a date vector
as the index, but not required.

There are 3 restrictions on the index:
\itemize{
\item The size of the index must match the size of \code{.x}, they will not be
recycled to their common size.
\item The index must be an \emph{increasing} vector, but duplicate values
are allowed.
\item The index cannot have missing values.
}}

\item{before}{\verb{[vector(1) / Inf]}

The number of values before or after the current element of \code{.i} to
include in the sliding window. Set to \code{Inf} to select all elements
before or after the current element. Negative values are allowed, which
allows you to "look forward" from the current element if used as the
\code{.before} value, or "look backwards" if used as \code{.after}.

Any object that can be added or subtracted from \code{.i} with \code{+} and \code{-}
can be used. For example, a lubridate period, such as \code{\link[lubridate:period]{lubridate::weeks()}}.

The ranges that result from computing \code{.i - .before} and \code{.i + .after}
have the same 3 restrictions as \code{.i} itself.}

\item{after}{\verb{[vector(1) / Inf]}

The number of values before or after the current element of \code{.i} to
include in the sliding window. Set to \code{Inf} to select all elements
before or after the current element. Negative values are allowed, which
allows you to "look forward" from the current element if used as the
\code{.before} value, or "look backwards" if used as \code{.after}.

Any object that can be added or subtracted from \code{.i} with \code{+} and \code{-}
can be used. For example, a lubridate period, such as \code{\link[lubridate:period]{lubridate::weeks()}}.

The ranges that result from computing \code{.i - .before} and \code{.i + .after}
have the same 3 restrictions as \code{.i} itself.}

\item{complete}{\verb{[logical(1)]}

Should the function be evaluated on complete windows only? If \code{FALSE},
the default, then partial computations will be allowed.}

\item{na_rm}{\verb{[logical(1)]}

Should missing values be removed from the computation?}
}
\value{
A double vector the same size as \code{x} containing the result of applying the
summary function over the sliding windows.
}
\description{
These functions are specialized variants of the most common ways that
\code{\link[=slide_index]{slide_index()}} is generally used. Notably, \code{\link[=slide_index_sum]{slide_index_sum()}} can be used
for rolling sums relative to an index (like a Date column), and
\code{\link[=slide_index_mean]{slide_index_mean()}} can be used for rolling averages.

These specialized variants are \emph{much} faster than using an otherwise
equivalent call constructed with \code{\link[=slide_index_dbl]{slide_index_dbl()}}, especially with a very
wide window.
}
\details{
For more details about the implementation, see the help page of
\code{\link[=slide_sum]{slide_sum()}}.
}
\examples{
x <- c(1, 5, 3, 2, 6, 10)
i <- as.Date("2019-01-01") + c(0, 1, 3, 4, 6, 8)

# `slide_index_sum()` can be used for rolling sums relative to an index,
# allowing you to "respect gaps" in your series. Notice that the rolling
# sum in row 3 is only computed from `2019-01-04` and `2019-01-02` since
# `2019-01-01` is more than two days before the current date.
data.frame(
  i = i,
  x = x,
  roll = slide_index_sum(x, i, before = 2)
)

# `slide_index_mean()` can be used for rolling averages
slide_index_mean(x, i, before = 2)

# Only evaluate the sum on windows that have the potential to be complete
slide_index_sum(x, i, before = 2, after = 1, complete = TRUE)
}
\seealso{
\code{\link[=slide_sum]{slide_sum()}}
}
