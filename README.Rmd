---
output: github_document
editor_options: 
  chunk_output_type: console
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```
# slurrr

<!-- badges: start -->
[![Travis build status](https://travis-ci.org/DavisVaughan/slurrr.svg?branch=master)](https://travis-ci.org/DavisVaughan/slurrr)
<!-- badges: end -->

The goal of slurrr is to provide a general purpose sliding window iterator, inspired heavily by SQL's window functions.

For examples and documentation, see `?slide`.

## Installation

You can NOT install the released version of slurrr from [CRAN](https://CRAN.R-project.org) yet.

And the development version from [GitHub](https://github.com/) with:

``` r
remotes::install_github("DavisVaughan/slurrr")
```

## Examples

The help page for `slide()` has many examples, but here are a few:

```{r}
library(slurrr)
```

The classic example would be to do a moving average. `slide()` handles this with a combination of the `.before` and `.after` arguments, which control the width of the window and the alignment.

```{r}
# Moving average (Aligned right)
slide_dbl(1:5, ~mean(.x), .before = 2)

# Align left
slide_dbl(1:5, ~mean(.x), .after = 2)

# Center aligned
slide_dbl(1:5, ~mean(.x), .before = 1, .after = 1)
```

With `unbounded()`, you can do a "cumulative slide" to compute cumulative expressions.

```{r}
slide(1:4, ~.x, .before = unbounded())

# De-cumulative (?) sliding
slide(1:4, ~.x, .after = unbounded())
```

With `.complete`, you can decide whether or not `.f` should be evaluated on incomplete windows. In the following example, the requested window size is 3, but the first two results are computed on windows of size 1 and 2 because partial results are allowed by default.

```{r}
slide(1:4, ~.x, .before = 2)

slide(1:4, ~.x, .before = 2, .complete = TRUE)
```

## Data frames

Unlike `purrr::map()`, `slide()` iterates over data frames in a row wise fashion. Interestingly this means the default of `slide()` becomes a generic row wise iterator, with nice syntax for accessing data frame columns.

```{r}
cars <- mtcars[1:4,]

slide(cars, ~.x)

slide_dbl(cars, ~.x$mpg + .x$drat)
```

You can still use all of the other arguments to `slide()` to flexibly slide over data frames too:

```{r}
slide(cars, ~.x, .before = 2)
```


## Window functions

A good explanation of window functions

https://www.postgresql.org/docs/9.1/sql-expressions.html#SYNTAX-WINDOW-FUNCTIONS

With a flowchart 

https://www.sqlite.org/windowfunctions.html

dbplyr

https://dbplyr.tidyverse.org/articles/translation-function.html#window-functions

Rows vs Range (range = logical offset such as dates / offset from current row's integer value)

https://www.vertica.com/docs/9.2.x/HTML/Content/Authoring/SQLReferenceManual/Functions/Analytic/window_frame_clause.htm?origin_team=T02V9CHFH#ROWSversusRANGE
